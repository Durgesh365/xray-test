app.py

from flask import Flask, request, jsonify
from flask_cors import CORS
import pandas as pd
from pymongo import MongoClient
import os
from datetime import datetime
import json
import logging
import re

app = Flask(__name__)
CORS(app)
app.secret_key = 'omnibase-secret-key-2024'

# MongoDB Configuration
client = MongoClient('mongodb://localhost:27017/')
db = client['omnibase_poc']
omnibase_collection = db['omnibase_collection']
data_catalog_collection = db['data_catalog']  # NEW: Data catalog collection

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load configuration files
def load_fixed_mappings():
    """Load fixed mappings from JSON file"""
    try:
        with open('fixed_mappings.json', 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error("fixed_mappings.json not found")
        return {}

def load_data_catalog():
    """Load data catalog from MongoDB collection"""
    try:
        catalog = data_catalog_collection.find_one()
        if catalog:
            # Remove MongoDB _id field
            catalog.pop('_id', None)
            return catalog
        else:
            logger.error("No data catalog found in MongoDB")
            return {}
    except Exception as e:
        logger.error(f"Error loading data catalog: {e}")
        return {}

def validate_field(value, field_name, field_spec, asset_type):
    """Validate a field against data catalog specifications"""
    errors = []
    
    # Skip validation if value is None and field is not required
    if value is None or (isinstance(value, (int, float)) and pd.isna(value)):
        if field_spec.get('required', False):
            errors.append(f"{field_name} is required but got null/empty")
        return errors
    
    # Type validation
    field_type = field_spec.get('type')
    
    if field_type == 'string':
        if not isinstance(value, str):
            try:
                value = str(value)  # Try to convert to string
            except:
                errors.append(f"{field_name} should be string but got {type(value).__name__}")
    
    elif field_type == 'integer':
        if not isinstance(value, int):
            try:
                # Try to convert to integer
                if isinstance(value, float) and value.is_integer():
                    value = int(value)
                else:
                    value = int(float(value))  # Handle string numbers
            except (ValueError, TypeError):
                errors.append(f"{field_name} should be integer but got {type(value).__name__}: {value}")
    
    elif field_type == 'number':
        if not isinstance(value, (int, float)):
            try:
                value = float(value)
            except (ValueError, TypeError):
                errors.append(f"{field_name} should be number but got {type(value).__name__}: {value}")
    
    # Get validation rules
    validation_rules = field_spec.get('validation', {})
    
    # String validations
    if field_type in ['string'] and isinstance(value, str):
        value = value.strip()
        
        if 'min_length' in validation_rules and len(value) < validation_rules['min_length']:
            errors.append(f"{field_name} should be at least {validation_rules['min_length']} characters (got {len(value)})")
        
        if 'max_length' in validation_rules and len(value) > validation_rules['max_length']:
            errors.append(f"{field_name} should be at most {validation_rules['max_length']} characters (got {len(value)})")
        
        if 'allowed_values' in validation_rules:
            allowed_values = validation_rules['allowed_values']
            if value not in allowed_values:
                allowed_str = ", ".join([f"'{v}'" for v in allowed_values])
                errors.append(f"{field_name} should be one of: {allowed_str}. Got: '{value}'")
        
        if 'pattern' in validation_rules:
            pattern = validation_rules['pattern']
            if not re.match(pattern, value):
                errors.append(f"{field_name} should match pattern: {pattern}. Got: '{value}'")
    
    # Number validations  
    elif field_type in ['integer', 'number'] and isinstance(value, (int, float)):
        if 'min_value' in validation_rules and value < validation_rules['min_value']:
            errors.append(f"{field_name} should be at least {validation_rules['min_value']} (got {value})")
        
        if 'max_value' in validation_rules and value > validation_rules['max_value']:
            errors.append(f"{field_name} should be at most {validation_rules['max_value']} (got {value})")
    
    return errors

def validate_row(mapped_row, asset_type, data_catalog):
    """Validate a complete row against data catalog"""
    validation_results = {
        'is_valid': True,
        'errors': [],
        'warnings': []
    }
    
    asset_catalog = data_catalog.get(asset_type, {})
    
    for field_name, value in mapped_row.items():
        # Skip system fields
        if field_name in ['import_date', 'asset_type', 'site_id', 'original_data']:
            continue
            
        # Get field specification from data catalog
        field_spec = asset_catalog.get(field_name)
        if not field_spec:
            validation_results['warnings'].append(f"Unknown field in catalog: {field_name}")
            continue
        
        # Validate the field
        field_errors = validate_field(value, field_name, field_spec, asset_type)
        if field_errors:
            validation_results['errors'].extend(field_errors)
    
    validation_results['is_valid'] = len(validation_results['errors']) == 0
    return validation_results

def process_single_row(row, mappings):
    """Process a single row with the given mappings"""
    mapped_row = {}
    
    # Apply field mappings
    for source_field, target_field in mappings.items():
        if source_field in row and pd.notna(row[source_field]):
            mapped_row[target_field] = row[source_field]
        else:
            mapped_row[target_field] = None
    
    return mapped_row

def get_preview_data(grouped_data, records_per_type=5):
    """Extract preview data for frontend display, separated by asset type"""
    preview_data = {}
    
    for asset_type, components in grouped_data.items():
        # Take first few records for this asset type
        preview_records = []
        for i, component in enumerate(components[:records_per_type]):
            preview_record = {
                'record_number': i + 1
            }
            
            # Add all component fields (excluding metadata)
            for key, value in component.items():
                if key not in ['import_date', 'original_data']:
                    preview_record[key] = value
            
            preview_records.append(preview_record)
        
        preview_data[asset_type] = preview_records
    
    return preview_data

# ... [Keep all the existing routes: /api/sites, /api/assets, /api/analyze-excel] ...



@app.route('/api/analyze-excel', methods=['POST'])
def analyze_excel():
    """Analyze Excel file and return headers with mappings"""
    try:
        if 'file' not in request.files:
            return jsonify({"error": "No file uploaded"}), 400
        
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
        
        if not file.filename.endswith(('.xlsx', '.xls')):
            return jsonify({"error": "Please upload an Excel file"}), 400
        
        # Read Excel file
        df = pd.read_excel(file)
        headers = list(df.columns)
        
        # Check if ASSET_TYPE column exists
        has_asset_type = 'ASSET_TYPE' in headers
        
        if has_asset_type:
            # Get unique asset types
            asset_types = df['ASSET_TYPE'].dropna().unique()
            detected_asset_types = []
            combined_mappings = {}
            
            all_mappings = load_fixed_mappings()
            
            # NEW: Create mapping details for each asset type
            asset_type_mappings = {}
            for asset_type in asset_types:
                asset_type_str = str(asset_type)
                if asset_type_str in all_mappings:
                    detected_asset_types.append(asset_type_str)
                    # Add mappings for this asset type
                    combined_mappings.update(all_mappings[asset_type_str])
                    # Store individual mappings for frontend
                    asset_type_mappings[asset_type_str] = all_mappings[asset_type_str]
            
            response_data = {
                "headers": headers,
                "mappings": combined_mappings,
                "asset_type": "mixed" if len(detected_asset_types) > 1 else detected_asset_types[0] if detected_asset_types else "unknown",
                "detected_asset_types": detected_asset_types,
                "has_asset_type_column": True,
                "row_count": len(df),
                "asset_type_counts": {asset_type: len(df[df['ASSET_TYPE'] == asset_type]) for asset_type in detected_asset_types},
                "asset_type_mappings": asset_type_mappings  # NEW: Send individual mappings
            }
        else:
            # No asset type column - show empty mappings
            response_data = {
                "headers": headers,
                "mappings": {},
                "asset_type": "unknown",
                "detected_asset_types": [],
                "has_asset_type_column": False,
                "row_count": len(df),
                "asset_type_counts": {},
                "asset_type_mappings": {},  # NEW
                "warning": "No ASSET_TYPE column found. Please add ASSET_TYPE column to your Excel file."
            }
        
        return jsonify(response_data)
        
    except Exception as e:
        logger.error(f"Error analyzing Excel: {str(e)}")
        return jsonify({"error": f"Error processing file: {str(e)}"}), 500

@app.route('/api/data-preview', methods=['GET'])
def get_data_preview():
    """Get paginated preview of stored data"""
    try:
        site_id = request.args.get('site_id')
        asset_id = request.args.get('asset_id')
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 10))
        
        if not site_id or not asset_id:
            return jsonify({"error": "Site ID and Asset ID are required"}), 400
        
        document_id = f"site_{site_id}_asset_{asset_id}"
        document = omnibase_collection.find_one({'_id': document_id})
        
        if not document:
            return jsonify({"error": "No data found for the specified site and asset"}), 404
        
        # Extract all components for pagination
        all_components = []
        for asset_type, components in document.get('components', {}).items():
            for component in components:
                flat_component = {
                    'asset_type': asset_type,
                    '_id': component.get('_id')  # Add if available
                }
                # Add all component fields
                for key, value in component.items():
                    if key not in ['_id', 'import_date', 'original_data']:
                        flat_component[key] = value
                all_components.append(flat_component)
        
        # Simple pagination
        start_idx = (page - 1) * limit
        end_idx = start_idx + limit
        paginated_data = all_components[start_idx:end_idx]
        
        return jsonify({
            "data": paginated_data,
            "pagination": {
                "page": page,
                "limit": limit,
                "total_records": len(all_components),
                "total_pages": (len(all_components) + limit - 1) // limit
            }
        })
        
    except Exception as e:
        logger.error(f"Error getting data preview: {str(e)}")
        return jsonify({"error": f"Error retrieving data: {str(e)}"}), 500   
    
@app.route('/api/sites', methods=['GET'])
def get_sites():
    """Get available sites"""
    sites = [
        {"id": 1, "name": "Texas Wind Farm"},
        {"id": 2, "name": "California Solar Park"},
        {"id": 3, "name": "Arizona Power Plant"},
        {"id": 4, "name": "Nevada Energy Complex"}
    ]
    return jsonify(sites)

@app.route('/api/assets', methods=['GET'])
def get_assets():
    """Get available asset types"""
    assets = [
        {"id": 1, "name": "Turbine", "type": "turbine"},
        {"id": 2, "name": "Solar Panel", "type": "solar_panel"},
        {"id": 3, "name": "Boiler", "type": "boiler"},
        {"id": 4, "name": "Generator", "type": "generator"}
    ]
    return jsonify(assets)

@app.route('/api/ingest', methods=['POST'])
def ingest_data():
    """Ingest Excel data into database with validation"""
    try:
        if 'file' not in request.files:
            return jsonify({"error": "No file uploaded"}), 400
        
        file = request.files['file']
        site_id = request.form.get('site_id')
        asset_id = request.form.get('asset_id')
        
        if not site_id or not asset_id:
            return jsonify({"error": "Site ID and Asset ID are required"}), 400
        
        # Save uploaded file temporarily
        file_path = f"temp_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        file.save(file_path)
        
        # Read Excel file
        df = pd.read_excel(file_path)
        
        # Check if ASSET_TYPE column exists
        if 'ASSET_TYPE' not in df.columns:
            if os.path.exists(file_path):
                os.remove(file_path)
            return jsonify({"error": "ASSET_TYPE column not found in Excel file"}), 400
        
        # Remove rows with missing asset_type
        df = df.dropna(subset=['ASSET_TYPE'])
        
        if len(df) == 0:
            if os.path.exists(file_path):
                os.remove(file_path)
            return jsonify({"error": "No valid rows found after removing rows with missing ASSET_TYPE"}), 400
        
        # Get all mappings and data catalog
        all_mappings = load_fixed_mappings()
        data_catalog = load_data_catalog()
        
        # Group by asset type and process
        grouped_data = {}
        total_records = 0
        validation_results = {
            'total_rows': len(df),
            'valid_rows': 0,
            'invalid_rows': 0,
            'row_errors': {}
        }
        
        for asset_type, group_df in df.groupby('ASSET_TYPE'):
            asset_type_str = str(asset_type)
            
            # Skip if no mappings for this asset type
            if asset_type_str not in all_mappings:
                logger.warning(f"No mappings found for asset type: {asset_type_str}")
                continue
            
            mappings = all_mappings[asset_type_str]
            asset_data = []
            
            for index, row in group_df.iterrows():
                # Process the row
                mapped_row = process_single_row(row, mappings)
                
                # Add metadata
                mapped_row['import_date'] = datetime.utcnow()
                mapped_row['original_data'] = row.where(pd.notna(row), None).to_dict()
                
                # Validate the row
                validation = validate_row(mapped_row, asset_type_str, data_catalog)
                
                if validation['is_valid']:
                    asset_data.append(mapped_row)
                    validation_results['valid_rows'] += 1
                else:
                    validation_results['invalid_rows'] += 1
                    excel_row_number = index + 2  # +2 for Excel row numbers (header is row 1)
                    validation_results['row_errors'][excel_row_number] = {
                        'asset_type': asset_type_str,
                        'errors': validation['errors'],
                        'warnings': validation['warnings']
                    }
                
                total_records += 1
            
            grouped_data[asset_type_str] = asset_data
        
        # Only proceed if we have valid data
        if validation_results['valid_rows'] == 0:
            if os.path.exists(file_path):
                os.remove(file_path)
            return jsonify({
                "success": False,
                "error": "No valid data found after validation",
                "validation_summary": validation_results
            }), 400
        
        # Create site document with asset_id
        document_id = f"site_{site_id}_asset_{asset_id}"
        site_document = {
            '_id': document_id,
            'siteId': int(site_id),
            'assetId': int(asset_id),
            'last_updated': datetime.utcnow(),
            'components': grouped_data
        }
        
        # Insert into database
        result = omnibase_collection.replace_one(
            {'_id': document_id},
            site_document,
            upsert=True
        )
        
        # Clean up temporary file
        if os.path.exists(file_path):
            os.remove(file_path)
        
        # Prepare response with preview data
        asset_type_counts = {asset_type: len(data) for asset_type, data in grouped_data.items()}
        preview_data = get_preview_data(grouped_data)
        
        response_data = {
            "success": True,
            "message": f"Successfully ingested data for site {site_id}, asset {asset_id}",
            "document_id": document_id,
            "site_id": int(site_id),
            "asset_id": int(asset_id),
            "total_records": total_records,
            "asset_type_counts": asset_type_counts,
            "preview_data": preview_data,
            "validation_summary": {
                "total_processed": validation_results['total_rows'],
                "successful": validation_results['valid_rows'],
                "failed": validation_results['invalid_rows']
            },
            "structure": "hierarchical"
        }
        
        # Add error details if there were failures
        if validation_results['invalid_rows'] > 0:
            response_data["validation_errors"] = validation_results['row_errors']
        
        return jsonify(response_data)
            
    except Exception as e:
        logger.error(f"Error during ingestion: {str(e)}")
        if 'file_path' in locals() and os.path.exists(file_path):
            os.remove(file_path)
        return jsonify({"error": f"Error ingesting data: {str(e)}"}), 500
    

if __name__ == '__main__':
    app.run(debug=True, port=5000)


backend\fixed_mappings.json
{
  "signal": {
    "IO-Card": "io_card",
    "IO-Card-Manu": "io_card_manufacturer",
    "IO-Card-Partnumber": "io_card_partnumber",
    "IO-Card-Desc": "io_card_description",
    "Channel": "channel",
    "Function-Tag": "function_tag",
    "Signal-Tag": "signal_tag",
    "Function-Desc": "function_description",
    "ASSET_TYPE": "asset_type"
  },
  "cable": {
    "Cable-Name": "cable_name",
    "Cable-Type": "cable_type",
    "Cable-TypeKey": "cable_type_key",
    "Cable-Core": "cable_core",
    "Start-Point-Comp": "start_point_component",
    "Start-Point-Comp-Conn": "start_point_connection",
    "End-Point-Comp": "end_point_component",
    "End-Point-Comp-Conn": "end_point_connection",
    "ASSET_TYPE": "asset_type"
  }
}


backend\initialize_data_catalog.py
from pymongo import MongoClient
import json

def initialize_data_catalog():
    """One-time script to initialize data_catalog collection"""
    client = MongoClient('mongodb://localhost:27017/')
    db = client['omnibase_poc']
    data_catalog_collection = db['data_catalog']
    
    # Drop existing collection to start fresh
    data_catalog_collection.drop()
    
    # Data catalog schema with validation rules
    data_catalog = {
        "signal": {
            "io_card": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 2,
                    "max_length": 50
                }
            },
            "io_card_manufacturer": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 2,
                    "max_length": 100
                }
            },
            "io_card_partnumber": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 2,
                    "max_length": 50
                }
            },
            "io_card_description": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 5,
                    "max_length": 200
                }
            },
            "channel": {
                "unit": "number", 
                "type": "integer", 
                "required": True,
                "validation": {
                    "min_value": 1,
                    "max_value": 32
                }
            },
            "function_tag": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 3,
                    "max_length": 20,
                    "pattern": "^[A-Z]{2,3}-[0-9]{3}$"  # Pattern like FIC-101, LSL-201
                }
            },
            "signal_tag": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 5,
                    "max_length": 20,
                    "pattern": "^[A-Z]{2}-[0-9]{3}-[0-9]{2}$"  # Pattern like AI-001-01
                }
            },
            "function_description": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 5,
                    "max_length": 100
                }
            },
            "asset_type": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "allowed_values": ["signal", "cable"]
                }
            }
        },
        "cable": {
            "cable_name": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 3,
                    "max_length": 20,
                    "pattern": "^[A-Z]+-[0-9]{3}$"  # Pattern like POWER-001
                }
            },
            "cable_type": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "allowed_values": ["Power", "Control", "Instrumentation", "Communication"]
                }
            },
            "cable_type_key": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 3,
                    "max_length": 20
                }
            },
            "cable_core": {
                "unit": "number", 
                "type": "integer", 
                "required": True,
                "validation": {
                    "min_value": 1,
                    "max_value": 50
                }
            },
            "start_point_component": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 3,
                    "max_length": 20
                }
            },
            "start_point_connection": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 1,
                    "max_length": 10
                }
            },
            "end_point_component": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "min_length": 3,
                    "max_length": 20
                }
            },
            "end_point_connection": {
                "unit": "text", 
                "type": "string", 
                "required": False,
                "validation": {
                    "min_length": 1,
                    "max_length": 10
                }
            },
            "asset_type": {
                "unit": "text", 
                "type": "string", 
                "required": True,
                "validation": {
                    "allowed_values": ["signal", "cable"]
                }
            }
        }
    }
    
    # Insert into collection
    result = data_catalog_collection.insert_one(data_catalog)
    print(f"Data catalog initialized successfully! Document ID: {result.inserted_id}")
    
    # Verify insertion
    doc = data_catalog_collection.find_one()
    print(f"Catalog contains {len(doc['signal'])} signal fields and {len(doc['cable'])} cable fields")

if __name__ == "__main__":
    initialize_data_catalog()





frontend\src\components\Screens.js
import React, { useState } from "react";

const Screens = () => {
  const [currentScreen, setCurrentScreen] = useState(1);
  const [selectedSite, setSelectedSite] = useState("");
  const [selectedAsset, setSelectedAsset] = useState("");
  const [selectedFile, setSelectedFile] = useState(null);
  const [mappingType, setMappingType] = useState("fixed");
  const [excelHeaders, setExcelHeaders] = useState([]);
  const [mappings, setMappings] = useState({});
  const [loading, setLoading] = useState(false);
  const [ingestResult, setIngestResult] = useState(null);
  const [assetType, setAssetType] = useState("");
  const [detectedAssetTypes, setDetectedAssetTypes] = useState([]);
  const [hasAssetTypeColumn, setHasAssetTypeColumn] = useState(false);
  const [assetTypeCounts, setAssetTypeCounts] = useState({});
  const [allMappings, setAllMappings] = useState({});

  //  State for validation errors
  const [validationErrors, setValidationErrors] = useState(null);

  // Mock data
  const sites = [
    { id: 1, name: "Texas Plant" },
    { id: 2, name: "California Facility" },
    { id: 3, name: "Arizona Site" },
    { id: 4, name: "Nevada Complex" },
  ];

  const assets = [
    { id: 1, name: "Control System", type: "control" },
    { id: 2, name: "Power System", type: "power" },
    { id: 3, name: "Instrumentation", type: "instrument" },
    { id: 4, name: "Network System", type: "network" },
  ];

  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setSelectedFile(file);
    setLoading(true);
    setValidationErrors(null); // Reset errors

    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await fetch("http://localhost:5000/api/analyze-excel", {
        method: "POST",
        body: formData,
      });

      const data = await response.json();

      if (response.ok) {
        setExcelHeaders(data.headers);
        setMappings(data.mappings);
        setAssetType(data.asset_type || data.assetType || "");
        setDetectedAssetTypes(
          data.detected_asset_types || data.detectedAssetTypes || []
        );
        setHasAssetTypeColumn(
          data.has_asset_type_column || data.hasAssetTypeColumn || false
        );
        setAssetTypeCounts(
          data.asset_type_counts || data.assetTypeCounts || {}
        );
        setAllMappings(
          data.asset_type_mappings || data.assetTypeMappings || {}
        );

        setCurrentScreen(4);
      } else {
        alert(data.error);
      }
    } catch (error) {
      alert("Error analyzing Excel file: " + error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleIngest = async () => {
    if (!selectedFile) return;

    setLoading(true);
    setValidationErrors(null); // Reset errors

    const formData = new FormData();
    formData.append("file", selectedFile);
    formData.append("site_id", selectedSite);
    formData.append("asset_id", selectedAsset);

    try {
      const response = await fetch("http://localhost:5000/api/ingest", {
        method: "POST",
        body: formData,
      });

      const data = await response.json();

      if (response.ok) {
        setIngestResult(data);
        setCurrentScreen(5);
      } else {
        // Handle validation errors
        if (data.validation_summary) {
          setValidationErrors(data);
        } else {
          alert(data.error || "Error ingesting data");
        }
      }
    } catch (error) {
      alert("Error ingesting data: " + error.message);
    } finally {
      setLoading(false);
    }
  };
  const renderScreen1 = () => (
    <div className="screen-container">
      <h2>1. Select Site & Asset</h2>
      <p className="screen-description">
        Choose the site and asset for data ingestion
      </p>

      <div className="form-group">
        <label htmlFor="site">Select Site</label>
        <select
          id="site"
          className="form-control"
          value={selectedSite}
          onChange={(e) => setSelectedSite(e.target.value)}
        >
          <option value="">Choose a site...</option>
          {sites.map((site) => (
            <option key={site.id} value={site.id}>
              {site.name}
            </option>
          ))}
        </select>
      </div>

      {/* NEW: Asset dropdown */}
      <div className="form-group">
        <label htmlFor="asset">Select Asset</label>
        <select
          id="asset"
          className="form-control"
          value={selectedAsset}
          onChange={(e) => setSelectedAsset(e.target.value)}
        >
          <option value="">Choose an asset...</option>
          {assets.map((asset) => (
            <option key={asset.id} value={asset.id}>
              {asset.name} ({asset.type})
            </option>
          ))}
        </select>
      </div>

      <div className="navigation">
        <div></div>
        <button
          className="btn btn-primary"
          onClick={() => setCurrentScreen(2)}
          disabled={!selectedSite || !selectedAsset}
        >
          Next ‚Üí
        </button>
      </div>
    </div>
  );

  const renderScreen2 = () => (
    <div className="screen-container">
      <h2>2. Import Excel File</h2>
      <p className="screen-description">
        Upload your Excel file for data ingestion
      </p>

      <div
        className="file-upload"
        onClick={() => document.getElementById("file-input").click()}
      >
        <div className="upload-icon"></div>
        <h3>Upload Excel File</h3>
        <p>Click to browse or drag and drop your .xlsx or .xls file</p>
        <input
          id="file-input"
          type="file"
          className="file-input"
          accept=".xlsx,.xls"
          onChange={handleFileUpload}
        />
        {selectedFile && (
          <p style={{ marginTop: "1rem", color: "#10b981" }}>
            Selected: {selectedFile.name}
          </p>
        )}
      </div>

      <div className="navigation">
        <button
          className="btn btn-secondary"
          onClick={() => setCurrentScreen(1)}
        >
          ‚Üê Back
        </button>
        <button
          className="btn btn-primary"
          onClick={() => setCurrentScreen(3)}
          disabled={!selectedFile}
        >
          Next ‚Üí
        </button>
      </div>
    </div>
  );

  const renderScreen3 = () => (
    <div className="screen-container">
      <h2>3. Select Mapping Type</h2>
      <p className="screen-description">
        Choose how to map Excel columns to database fields
      </p>

      <div className="form-group">
        <label>Mapping Type</label>
        <div className="radio-group">
          <label className="radio-option">
            <input
              type="radio"
              value="fixed"
              checked={mappingType === "fixed"}
              onChange={(e) => setMappingType(e.target.value)}
            />
            Fixed Mapping
          </label>
          <label className="radio-option">
            <input
              type="radio"
              value="flexible"
              checked={mappingType === "flexible"}
              onChange={(e) => setMappingType(e.target.value)}
              disabled
            />
            Flexible Mapping (Coming Soon)
          </label>
        </div>
        <p
          style={{ marginTop: "0.5rem", color: "#64748b", fontSize: "0.9rem" }}
        >
          Fixed mapping uses predefined field mappings. Flexible mapping allows
          custom field mapping.
        </p>
      </div>

      <div className="navigation">
        <button
          className="btn btn-secondary"
          onClick={() => setCurrentScreen(2)}
        >
          ‚Üê Back
        </button>
        <button className="btn btn-primary" onClick={() => setCurrentScreen(4)}>
          Next ‚Üí
        </button>
      </div>
    </div>
  );

  const renderScreen4 = () => (
    <div className="screen-container">
      <h2>4. Field Mapping Preview</h2>

      {/* Show validation errors if any */}
      {validationErrors && (
        <div
          style={{
            background: "#fef2f2",
            color: "#dc2626",
            padding: "15px",
            borderRadius: "8px",
            marginBottom: "20px",
            border: "1px solid #fecaca",
          }}
        >
          <h4 style={{ margin: "0 0 10px 0" }}>Validation Failed</h4>
          <p style={{ margin: "0" }}>{validationErrors.error}</p>
          {validationErrors.validation_summary && (
            <div style={{ marginTop: "10px" }}>
              <strong>Summary:</strong>{" "}
              {validationErrors.validation_summary.successful} valid,{" "}
              {validationErrors.validation_summary.failed} invalid out of{" "}
              {validationErrors.validation_summary.total_processed} records
            </div>
          )}
        </div>
      )}

      <div
        className="asset-type-info"
        style={{
          background: "#f0f9ff",
          padding: "15px",
          borderRadius: "8px",
          marginBottom: "20px",
        }}
      >
        <h3>Detected Asset Types</h3>
        {assetType === "mixed" ? (
          <div>
            <p>Multiple asset types detected in your file:</p>
            <ul>
              {detectedAssetTypes.map((type) => (
                <li key={type}>
                  <strong>{type}</strong>: {assetTypeCounts[type] || 0} records
                </li>
              ))}
            </ul>
            <p>
              <em>Each row will be processed according to its asset type</em>
            </p>
          </div>
        ) : assetType === "unknown" ? (
          <div style={{ color: "#dc2626" }}>
            <p>Could not detect asset type automatically.</p>
            <p>Please ensure your Excel file has an 'ASSET_TYPE' column.</p>
          </div>
        ) : assetType ? (
          <div>
            <p>
              Asset Type: <strong>{assetType}</strong>
            </p>
            <p>
              Records: <strong>{assetTypeCounts[assetType] || 0}</strong>
            </p>
          </div>
        ) : (
          <div style={{ color: "#dc2626" }}>
            <p>No asset type information available.</p>
          </div>
        )}
      </div>

      <p className="screen-description">
        Review how Excel columns will be mapped to database fields
      </p>

      <table className="mapping-table">
        <thead>
          <tr>
            <th>Excel Header</th>
            <th>Omnibase Field</th>
            <th>Applicable Asset Types</th>
          </tr>
        </thead>
        <tbody>
          {excelHeaders.map((header) => {
            const targetField = mappings[header];

            // NEW: Determine which asset types this column applies to
            const applicableAssetTypes = detectedAssetTypes.filter(
              (assetType) => {
                // Check if this header exists in the mappings for this asset type
                const assetMappings = allMappings[assetType] || {};
                return header in assetMappings;
              }
            );

            return (
              <tr key={header}>
                <td>{header}</td>
                <td>
                  {targetField ? (
                    <span style={{ color: "#10b981" }}>‚Üí {targetField}</span>
                  ) : (
                    <span style={{ color: "#ef4444" }}>No mapping</span>
                  )}
                </td>
                <td>
                  {applicableAssetTypes.length > 0 ? (
                    applicableAssetTypes.join(", ")
                  ) : (
                    <span style={{ color: "#ef4444" }}>None</span>
                  )}
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>

      {/* NEW: Show mapping details for each asset type */}
      {assetType === "mixed" && (
        <div style={{ marginTop: "2rem" }}>
          <h4> Mapping Details by Asset Type</h4>
          {detectedAssetTypes.map((assetType) => (
            <div
              key={assetType}
              style={{
                background: "#f8fafc",
                padding: "15px",
                borderRadius: "8px",
                margin: "10px 0",
                border: "1px solid #e2e8f0",
              }}
            >
              <h5 style={{ margin: "0 0 10px 0", color: "#475569" }}>
                {assetType.toUpperCase()} Mappings (
                {assetTypeCounts[assetType] || 0} records)
              </h5>
              <div style={{ fontSize: "0.9rem" }}>
                {Object.entries(allMappings[assetType] || {}).map(
                  ([source, target]) => (
                    <div
                      key={source}
                      style={{
                        display: "inline-block",
                        margin: "0 15px 5px 0",
                      }}
                    >
                      <strong>{source}</strong> ‚Üí <code>{target}</code>
                    </div>
                  )
                )}
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Warning for unknown asset type */}
      {assetType === "unknown" && (
        <div
          style={{
            background: "#fef2f2",
            color: "#dc2626",
            padding: "15px",
            borderRadius: "8px",
            marginTop: "20px",
            border: "1px solid #fecaca",
          }}
        >
          <h4>Attention Required</h4>
          <p>
            Your Excel file doesn't have an 'ASSET_TYPE' column and we couldn't
            automatically detect the asset type.
          </p>
          <p>
            Please add an 'ASSET_TYPE' column to your Excel file with values
            like 'signal', 'cable', etc.
          </p>
        </div>
      )}

      <div className="navigation">
        <button
          className="btn btn-secondary"
          onClick={() => setCurrentScreen(3)}
        >
          ‚Üê Back
        </button>
        <button
          className="btn btn-success"
          onClick={handleIngest}
          disabled={
            loading ||
            assetType === "unknown" ||
            Object.keys(mappings).length === 0
          }
        >
          {loading ? "Processing..." : "Ingest Data"}
        </button>
      </div>
    </div>
  );

  // NEW: Dedicated Error Screen for Validation Failures
  const renderErrorScreen = () => (
    <div className="screen-container">
      <div
        className="error-screen"
        style={{ textAlign: "center", padding: "2rem" }}
      >
        <div
          style={{ fontSize: "4rem", color: "#dc2626", marginBottom: "1rem" }}
        >
          ‚ùå
        </div>
        <h2>Data Validation Failed</h2>

        {validationErrors?.error && (
          <p style={{ fontSize: "1.2rem", margin: "1rem 0", color: "#dc2626" }}>
            {validationErrors.error}
          </p>
        )}

        {validationErrors?.validation_summary && (
          <div
            style={{
              background: "#fef2f2",
              padding: "20px",
              borderRadius: "8px",
              margin: "2rem 0",
              border: "1px solid #fecaca",
            }}
          >
            <h4>Validation Summary</h4>
            <div
              style={{
                display: "flex",
                justifyContent: "space-around",
                margin: "1rem 0",
              }}
            >
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "2rem",
                    color: "#16a34a",
                    fontWeight: "bold",
                  }}
                >
                  {validationErrors.validation_summary.successful}
                </div>
                <div>Valid Records</div>
              </div>
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "2rem",
                    color: "#dc2626",
                    fontWeight: "bold",
                  }}
                >
                  {validationErrors.validation_summary.failed}
                </div>
                <div>Invalid Records</div>
              </div>
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "2rem",
                    color: "#475569",
                    fontWeight: "bold",
                  }}
                >
                  {validationErrors.validation_summary.total_processed}
                </div>
                <div>Total Records</div>
              </div>
            </div>
          </div>
        )}

        {/* Detailed Validation Errors */}
        {validationErrors?.validation_errors &&
          Object.keys(validationErrors.validation_errors).length > 0 && (
            <div style={{ margin: "2rem 0" }}>
              <h4>üîç Detailed Validation Errors</h4>
              <p style={{ color: "#64748b", marginBottom: "1rem" }}>
                The following rows failed validation and were not imported:
              </p>

              <div
                style={{
                  maxHeight: "400px",
                  overflow: "auto",
                  border: "1px solid #e2e8f0",
                  borderRadius: "8px",
                }}
              >
                {Object.entries(validationErrors.validation_errors).map(
                  ([rowNumber, errorInfo]) => (
                    <div
                      key={rowNumber}
                      style={{
                        padding: "15px",
                        borderBottom: "1px solid #e2e8f0",
                        background: "#fef2f2",
                      }}
                    >
                      <div
                        style={{
                          fontWeight: "bold",
                          color: "#dc2626",
                          marginBottom: "8px",
                        }}
                      >
                        Excel Row {rowNumber} ({errorInfo.asset_type})
                      </div>
                      <div style={{ marginLeft: "20px" }}>
                        {errorInfo.errors.map((error, index) => (
                          <div
                            key={index}
                            style={{
                              color: "#dc2626",
                              marginBottom: "4px",
                              fontSize: "0.9rem",
                            }}
                          >
                            ‚Ä¢ {error}
                          </div>
                        ))}
                        {errorInfo.warnings &&
                          errorInfo.warnings.map((warning, index) => (
                            <div
                              key={index}
                              style={{
                                color: "#d97706",
                                marginBottom: "4px",
                                fontSize: "0.9rem",
                              }}
                            >
                              ‚Ä¢ {warning}
                            </div>
                          ))}
                      </div>
                    </div>
                  )
                )}
              </div>
            </div>
          )}

        {/* Action Buttons */}
        <div
          style={{
            display: "flex",
            gap: "1rem",
            justifyContent: "center",
            marginTop: "2rem",
          }}
        >
          <button
            className="btn btn-secondary"
            onClick={() => {
              setValidationErrors(null);
              setCurrentScreen(2); // Go back to file upload
            }}
          >
            ‚Üê Upload New File
          </button>
          <button
            className="btn btn-primary"
            onClick={() => {
              setValidationErrors(null);
              setCurrentScreen(4); // Go back to mapping preview
            }}
          >
            ‚Üª Try Again
          </button>
          <button
            className="btn btn-success"
            onClick={() => {
              alert("Force ingest feature would go here");
            }}
            disabled
          >
            Ingest Valid Data Only
          </button>
        </div>

        {/* Help Section */}
        <div
          style={{
            background: "#f0f9ff",
            padding: "15px",
            borderRadius: "8px",
            marginTop: "2rem",
            textAlign: "left",
          }}
        >
          <h5>How to Fix These Errors</h5>
          <ul style={{ margin: "10px 0", paddingLeft: "20px" }}>
            <li>Check that required fields are not empty</li>
            <li>Ensure data types match (numbers, text, etc.)</li>
            <li>Verify that values are within allowed ranges</li>
            <li>Check pattern requirements (e.g., FIC-101 format)</li>
            <li>
              Ensure cable types are one of: Power, Control, Instrumentation,
              Communication
            </li>
          </ul>
        </div>
      </div>
    </div>
  );

  const renderScreen5 = () => (
    <div className="screen-container">
      <div className="success-screen">
        <div className="success-icon"></div>
        <h2>Data Ingestion Complete!</h2>
        <p style={{ fontSize: "1.2rem", margin: "1rem 0" }}>
          Successfully ingested data for Site{" "}
          <strong>{ingestResult?.site_id}</strong>, Asset{" "}
          <strong>{ingestResult?.asset_id}</strong>
        </p>

        {/* Validation Summary in Success Screen */}
        {ingestResult?.validation_summary &&
          ingestResult.validation_summary.failed > 0 && (
            <div
              style={{
                background: "#fffbeb",
                padding: "15px",
                borderRadius: "8px",
                margin: "1rem 0",
                border: "1px solid #fcd34d",
              }}
            >
              <h4 style={{ color: "#d97706", margin: "0 0 10px 0" }}>
                Partial Success
              </h4>
              <p style={{ margin: "0", color: "#92400e" }}>
                <strong>{ingestResult.validation_summary.successful}</strong>{" "}
                records imported successfully, but{" "}
                <strong>{ingestResult.validation_summary.failed}</strong>{" "}
                records failed validation and were skipped.
              </p>

              {/* Show failed records if any */}
              {ingestResult?.validation_errors && (
                <details style={{ marginTop: "10px" }}>
                  <summary style={{ cursor: "pointer", color: "#92400e" }}>
                    View Failed Records (
                    {Object.keys(ingestResult.validation_errors).length})
                  </summary>
                  <div
                    style={{
                      maxHeight: "200px",
                      overflow: "auto",
                      marginTop: "10px",
                      background: "#fef3c7",
                      padding: "10px",
                      borderRadius: "4px",
                    }}
                  >
                    {Object.entries(ingestResult.validation_errors).map(
                      ([rowNumber, errorInfo]) => (
                        <div
                          key={rowNumber}
                          style={{ marginBottom: "8px", fontSize: "0.8rem" }}
                        >
                          <strong>Row {rowNumber}:</strong>{" "}
                          {errorInfo.errors.join(", ")}
                        </div>
                      )
                    )}
                  </div>
                </details>
              )}
            </div>
          )}

        {/* Rest of success screen content */}
        {ingestResult?.asset_type_counts && (
          <div
            style={{
              background: "#f0f9ff",
              padding: "15px",
              borderRadius: "8px",
              margin: "1rem 0",
            }}
          >
            <h4>Ingestion Summary</h4>
            <ul>
              {Object.entries(ingestResult.asset_type_counts).map(
                ([type, count]) => (
                  <li key={type}>
                    <strong>{type}</strong>: {count} records
                  </li>
                )
              )}
            </ul>
            <p>
              Total Records: <strong>{ingestResult?.total_records}</strong>
            </p>
          </div>
        )}

        {/* Data Preview Section */}
        {ingestResult?.preview_data &&
          Object.keys(ingestResult.preview_data).length > 0 && (
            <div style={{ margin: "2rem 0" }}>
              <h4>Data Preview</h4>
              {Object.entries(ingestResult.preview_data).map(
                ([assetType, records]) => (
                  <div key={assetType} style={{ marginBottom: "2rem" }}>
                    <h5
                      style={{
                        background: "#4f46e5",
                        color: "white",
                        padding: "10px 15px",
                        borderRadius: "6px",
                        marginBottom: "1rem",
                      }}
                    >
                      {assetType.toUpperCase()} Data ({records.length} records
                      shown)
                    </h5>
                    {records.length > 0 && (
                      <div
                        style={{
                          maxHeight: "300px",
                          overflow: "auto",
                          border: "1px solid #e2e8f0",
                          borderRadius: "8px",
                          marginBottom: "1rem",
                        }}
                      >
                        <table
                          style={{
                            width: "100%",
                            borderCollapse: "collapse",
                            minWidth: "600px",
                          }}
                        >
                          <thead
                            style={{
                              position: "sticky",
                              top: 0,
                              background: "#f8fafc",
                            }}
                          >
                            <tr>
                              {Object.keys(records[0]).map((key) => (
                                <th
                                  key={key}
                                  style={{
                                    padding: "10px",
                                    textAlign: "left",
                                    borderBottom: "2px solid #e2e8f0",
                                    background: "#f8fafc",
                                    whiteSpace: "nowrap",
                                    fontSize: "0.8rem",
                                  }}
                                >
                                  {key.replace(/_/g, " ").toUpperCase()}
                                </th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {records.map((record, index) => (
                              <tr
                                key={index}
                                style={{ borderBottom: "1px solid #e2e8f0" }}
                              >
                                {Object.entries(record).map(([key, value]) => (
                                  <td
                                    key={key}
                                    style={{
                                      padding: "10px",
                                      borderBottom: "1px solid #e2e8f0",
                                      wordBreak: "break-word",
                                      fontSize: "0.8rem",
                                    }}
                                  >
                                    {value === null || value === "" ? (
                                      <span
                                        style={{
                                          color: "#94a3b8",
                                          fontStyle: "italic",
                                        }}
                                      >
                                        NULL
                                      </span>
                                    ) : (
                                      String(value)
                                    )}
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}
                  </div>
                )
              )}
            </div>
          )}

        <div
          style={{
            display: "flex",
            gap: "1rem",
            justifyContent: "center",
            marginTop: "2rem",
          }}
        >
          <button
            className="btn btn-primary"
            onClick={() => {
              setCurrentScreen(1);
              setSelectedSite("");
              setSelectedAsset("");
              setSelectedFile(null);
              setIngestResult(null);
              setAssetType("");
              setDetectedAssetTypes([]);
              setHasAssetTypeColumn(false);
              setAssetTypeCounts({});
              setAllMappings({});
              setValidationErrors(null);
            }}
          >
            Start New Import
          </button>
        </div>
      </div>
    </div>
  );

  if (loading) {
    return (
      <div className="screen-container">
        <div className="loading">
          <h2>Processing...</h2>
          <p>Please wait while we process your data</p>
        </div>
      </div>
    );
  }

  // UPDATED: Add error screen to the flow
  switch (currentScreen) {
    case 1:
      return renderScreen1();
    case 2:
      return renderScreen2();
    case 3:
      return renderScreen3();
    case 4:
      return renderScreen4();
    case 5:
      // Show error screen if there are validation errors, otherwise success screen
      if (validationErrors && !validationErrors.success) {
        return renderErrorScreen();
      }
      return renderScreen5();
    default:
      return renderScreen1();
  }
};

export default Screens;







frontend\src\App.css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    "Helvetica Neue", Arial, sans-serif;
  background: #fafafa;
  color: #1a1a1a;
  line-height: 1.6;
}

.App {
  min-height: 100vh;
}

.app-header {
  background: #ffffff;
  color: #1a1a1a;
  padding: 1.5rem 2rem;
  border-bottom: 1px solid #e5e5e5;
}

.app-header h1 {
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.app-header p {
  font-size: 0.95rem;
  color: #666666;
}

/* Screen Container */
.screen-container {
  max-width: 800px;
  margin: 2rem auto;
  padding: 2rem;
  background: white;
  border-radius: 4px;
  border: 1px solid #e5e5e5;
}

/* Form Elements */
.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #333333;
  font-size: 0.95rem;
}

.form-control {
  width: 100%;
  padding: 0.625rem 0.875rem;
  border: 1px solid #d4d4d4;
  border-radius: 4px;
  font-size: 0.95rem;
  transition: border-color 0.2s ease;
}

.form-control:focus {
  outline: none;
  border-color: #525252;
}

/* Buttons */
.btn {
  padding: 0.625rem 1.25rem;
  border: none;
  border-radius: 4px;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
  display: inline-block;
  text-align: center;
}

.btn-primary {
  background: #1a1a1a;
  color: white;
}

.btn-primary:hover {
  background: #333333;
}

.btn-secondary {
  background: #f5f5f5;
  color: #1a1a1a;
  border: 1px solid #d4d4d4;
}

.btn-secondary:hover {
  background: #e5e5e5;
}

.btn-success {
  background: #18181b;
  color: white;
}

.btn-success:hover {
  background: #27272a;
}

/* Navigation */
.navigation {
  display: flex;
  justify-content: space-between;
  margin-top: 2rem;
  padding-top: 1.5rem;
  border-top: 1px solid #e5e5e5;
}

/* Radio Group */
.radio-group {
  display: flex;
  gap: 2rem;
  margin-top: 0.5rem;
}

.radio-option {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}

.radio-option input[type="radio"] {
  margin: 0;
  accent-color: #1a1a1a;
}

/* Mapping Table */
.mapping-table {
  width: 100%;
  border-collapse: collapse;
  margin: 1rem 0;
  font-size: 0.95rem;
}

.mapping-table th,
.mapping-table td {
  padding: 0.875rem 1rem;
  text-align: left;
  border-bottom: 1px solid #e5e5e5;
}

.mapping-table th {
  background: #fafafa;
  font-weight: 500;
  color: #1a1a1a;
}

.mapping-table tr:hover {
  background: #fafafa;
}

/* File Upload */
.file-upload {
  border: 1px dashed #d4d4d4;
  border-radius: 4px;
  padding: 2rem;
  text-align: center;
  transition: border-color 0.2s ease;
  cursor: pointer;
  background: #fafafa;
}

.file-upload:hover {
  border-color: #525252;
  background: #f5f5f5;
}

.file-upload.dragover {
  border-color: #1a1a1a;
  background: #f5f5f5;
}

.file-input {
  display: none;
}

.upload-icon {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: #525252;
}

/* Success Screen */
.success-screen {
  text-align: center;
  padding: 3rem 2rem;
}

.success-icon {
  font-size: 3rem;
  color: #18181b;
  margin-bottom: 1rem;
}

/* Loading */
.loading {
  text-align: center;
  padding: 2rem;
  color: #525252;
}

/* Error Screen Styles */
.error-screen {
  text-align: center;
  padding: 2rem;
}

.error-icon {
  font-size: 3rem;
  color: #dc2626;
  margin-bottom: 1rem;
}

/* Validation error highlights */
.validation-error {
  background: #fef2f2;
  border: 1px solid #fca5a5;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
  font-size: 0.95rem;
}

.validation-warning {
  background: #fffbeb;
  border: 1px solid #fde047;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
  font-size: 0.95rem;
}

/* Success with warnings */
.partial-success {
  background: #fffbeb;
  border: 1px solid #fde047;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
  font-size: 0.95rem;
}

/* Error details */
.error-details {
  background: #fafafa;
  border: 1px solid #e5e5e5;
  border-radius: 4px;
  padding: 0.875rem;
  margin: 0.5rem 0;
  font-size: 0.9rem;
  text-align: left;
}
li {
  list-style: none;
}









